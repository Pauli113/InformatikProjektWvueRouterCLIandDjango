{"ast":null,"code":"// Generated by CoffeeScript 1.12.4\nvar Inline, ParseException, ParseMore, Parser, Pattern, Utils;\nInline = require('./Inline');\nPattern = require('./Pattern');\nUtils = require('./Utils');\nParseException = require('./Exception/ParseException');\nParseMore = require('./Exception/ParseMore');\n\nParser = function () {\n  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\\\|>]*)\\\\s+)?(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\\\-((?<leadspaces>\\\\s+)(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');\n  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\{\\\\[].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\[\\\\{].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\\\d+');\n  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');\n  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\\n*)$');\n  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\\\%YAML[: ][\\\\d\\\\.]+.*\\n', 'm');\n  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\\\#.*?\\n)+', 'm');\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\\\-\\\\-\\\\-.*?\\n', 'm');\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\\\.\\\\.\\\\.\\\\s*$', 'm');\n  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};\n  Parser.prototype.CONTEXT_NONE = 0;\n  Parser.prototype.CONTEXT_SEQUENCE = 1;\n  Parser.prototype.CONTEXT_MAPPING = 2;\n\n  function Parser(offset) {\n    this.offset = offset != null ? offset : 0;\n    this.lines = [];\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.refs = {};\n  }\n\n  Parser.prototype.parse = function (value, exceptionOnInvalidType, objectDecoder) {\n    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;\n\n    if (exceptionOnInvalidType == null) {\n      exceptionOnInvalidType = false;\n    }\n\n    if (objectDecoder == null) {\n      objectDecoder = null;\n    }\n\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.lines = this.cleanup(value).split(\"\\n\");\n    data = null;\n    context = this.CONTEXT_NONE;\n    allowOverwrite = false;\n\n    while (this.moveToNextLine()) {\n      if (this.isCurrentLineEmpty()) {\n        continue;\n      }\n\n      if (\"\\t\" === this.currentLine[0]) {\n        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n\n      isRef = mergeNode = false;\n\n      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {\n        if (this.CONTEXT_MAPPING === context) {\n          throw new ParseException('You cannot define a sequence item when in a mapping');\n        }\n\n        context = this.CONTEXT_SEQUENCE;\n\n        if (data == null) {\n          data = [];\n        }\n\n        if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n\n        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(null);\n          }\n        } else {\n          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {\n            c = this.getRealCurrentLineNb();\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            block = values.value;\n            indent = this.getCurrentLineIndentation();\n\n            if (this.isNextLineIndented(false)) {\n              block += \"\\n\" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);\n            }\n\n            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));\n          }\n        }\n      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {\n        if (this.CONTEXT_SEQUENCE === context) {\n          throw new ParseException('You cannot define a mapping item when in a sequence');\n        }\n\n        context = this.CONTEXT_MAPPING;\n\n        if (data == null) {\n          data = {};\n        }\n\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n\n        try {\n          key = Inline.parseScalar(values.key);\n        } catch (error) {\n          e = error;\n          e.parsedLine = this.getRealCurrentLineNb() + 1;\n          e.snippet = this.currentLine;\n          throw e;\n        }\n\n        if ('<<' === key) {\n          mergeNode = true;\n          allowOverwrite = true;\n\n          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {\n            refName = values.value.slice(1);\n\n            if (this.refs[refName] == null) {\n              throw new ParseException('Reference \"' + refName + '\" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n\n            refValue = this.refs[refName];\n\n            if (typeof refValue !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n\n            if (refValue instanceof Array) {\n              for (i = j = 0, len = refValue.length; j < len; i = ++j) {\n                value = refValue[i];\n\n                if (data[name = String(i)] == null) {\n                  data[name] = value;\n                }\n              }\n            } else {\n              for (key in refValue) {\n                value = refValue[key];\n\n                if (data[key] == null) {\n                  data[key] = value;\n                }\n              }\n            }\n          } else {\n            if (values.value != null && values.value !== '') {\n              value = values.value;\n            } else {\n              value = this.getNextEmbedBlock();\n            }\n\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            parsed = parser.parse(value, exceptionOnInvalidType);\n\n            if (typeof parsed !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n\n            if (parsed instanceof Array) {\n              for (l = 0, len1 = parsed.length; l < len1; l++) {\n                parsedItem = parsed[l];\n\n                if (typeof parsedItem !== 'object') {\n                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);\n                }\n\n                if (parsedItem instanceof Array) {\n                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {\n                    value = parsedItem[i];\n                    k = String(i);\n\n                    if (!data.hasOwnProperty(k)) {\n                      data[k] = value;\n                    }\n                  }\n                } else {\n                  for (key in parsedItem) {\n                    value = parsedItem[key];\n\n                    if (!data.hasOwnProperty(key)) {\n                      data[key] = value;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (key in parsed) {\n                value = parsed[key];\n\n                if (!data.hasOwnProperty(key)) {\n                  data[key] = value;\n                }\n              }\n            }\n          }\n        } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n\n        if (mergeNode) {} else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = null;\n            }\n          } else {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);\n\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = val;\n            }\n          }\n        } else {\n          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);\n\n          if (allowOverwrite || data[key] === void 0) {\n            data[key] = val;\n          }\n        }\n      } else {\n        lineCount = this.lines.length;\n\n        if (1 === lineCount || 2 === lineCount && Utils.isEmpty(this.lines[1])) {\n          try {\n            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n\n          if (typeof value === 'object') {\n            if (value instanceof Array) {\n              first = value[0];\n            } else {\n              for (key in value) {\n                first = value[key];\n                break;\n              }\n            }\n\n            if (typeof first === 'string' && first.indexOf('*') === 0) {\n              data = [];\n\n              for (n = 0, len3 = value.length; n < len3; n++) {\n                alias = value[n];\n                data.push(this.refs[alias.slice(1)]);\n              }\n\n              value = data;\n            }\n          }\n\n          return value;\n        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {\n          try {\n            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n\n        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n\n      if (isRef) {\n        if (data instanceof Array) {\n          this.refs[isRef] = data[data.length - 1];\n        } else {\n          lastKey = null;\n\n          for (key in data) {\n            lastKey = key;\n          }\n\n          this.refs[isRef] = data[lastKey];\n        }\n      }\n    }\n\n    if (Utils.isEmpty(data)) {\n      return null;\n    } else {\n      return data;\n    }\n  };\n\n  Parser.prototype.getRealCurrentLineNb = function () {\n    return this.currentLineNb + this.offset;\n  };\n\n  Parser.prototype.getCurrentLineIndentation = function () {\n    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;\n  };\n\n  Parser.prototype.getNextEmbedBlock = function (indentation, includeUnindentedCollection) {\n    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;\n\n    if (indentation == null) {\n      indentation = null;\n    }\n\n    if (includeUnindentedCollection == null) {\n      includeUnindentedCollection = false;\n    }\n\n    this.moveToNextLine();\n\n    if (indentation == null) {\n      newIndent = this.getCurrentLineIndentation();\n      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);\n\n      if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    } else {\n      newIndent = indentation;\n    }\n\n    data = [this.currentLine.slice(newIndent)];\n\n    if (!includeUnindentedCollection) {\n      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);\n    }\n\n    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;\n    removeComments = !removeCommentsPattern.test(this.currentLine);\n\n    while (this.moveToNextLine()) {\n      indent = this.getCurrentLineIndentation();\n\n      if (indent === newIndent) {\n        removeComments = !removeCommentsPattern.test(this.currentLine);\n      }\n\n      if (removeComments && this.isCurrentLineComment()) {\n        continue;\n      }\n\n      if (this.isCurrentLineBlank()) {\n        data.push(this.currentLine.slice(newIndent));\n        continue;\n      }\n\n      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {\n        this.moveToPreviousLine();\n        break;\n      }\n\n      if (indent >= newIndent) {\n        data.push(this.currentLine.slice(newIndent));\n      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {} else if (0 === indent) {\n        this.moveToPreviousLine();\n        break;\n      } else {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    }\n\n    return data.join(\"\\n\");\n  };\n\n  Parser.prototype.moveToNextLine = function () {\n    if (this.currentLineNb >= this.lines.length - 1) {\n      return false;\n    }\n\n    this.currentLine = this.lines[++this.currentLineNb];\n    return true;\n  };\n\n  Parser.prototype.moveToPreviousLine = function () {\n    this.currentLine = this.lines[--this.currentLineNb];\n  };\n\n  Parser.prototype.parseValue = function (value, exceptionOnInvalidType, objectDecoder) {\n    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;\n\n    if (0 === value.indexOf('*')) {\n      pos = value.indexOf('#');\n\n      if (pos !== -1) {\n        value = value.substr(1, pos - 2);\n      } else {\n        value = value.slice(1);\n      }\n\n      if (this.refs[value] === void 0) {\n        throw new ParseException('Reference \"' + value + '\" does not exist.', this.currentLine);\n      }\n\n      return this.refs[value];\n    }\n\n    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {\n      modifiers = (ref = matches.modifiers) != null ? ref : '';\n      foldedIndent = Math.abs(parseInt(modifiers));\n\n      if (isNaN(foldedIndent)) {\n        foldedIndent = 0;\n      }\n\n      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);\n\n      if (matches.type != null) {\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        return Inline.parseScalar(matches.type + ' ' + val);\n      } else {\n        return val;\n      }\n    }\n\n    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '\"' || ref1 === \"'\") {\n      while (true) {\n        try {\n          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n        } catch (error) {\n          e = error;\n\n          if (e instanceof ParseMore && this.moveToNextLine()) {\n            value += \"\\n\" + Utils.trim(this.currentLine, ' ');\n          } else {\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n      }\n    } else {\n      if (this.isNextLineIndented()) {\n        value += \"\\n\" + this.getNextEmbedBlock();\n      }\n\n      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n    }\n  };\n\n  Parser.prototype.parseFoldedScalar = function (separator, indicator, indentation) {\n    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;\n\n    if (indicator == null) {\n      indicator = '';\n    }\n\n    if (indentation == null) {\n      indentation = 0;\n    }\n\n    notEOF = this.moveToNextLine();\n\n    if (!notEOF) {\n      return '';\n    }\n\n    isCurrentLineBlank = this.isCurrentLineBlank();\n    text = '';\n\n    while (notEOF && isCurrentLineBlank) {\n      if (notEOF = this.moveToNextLine()) {\n        text += \"\\n\";\n        isCurrentLineBlank = this.isCurrentLineBlank();\n      }\n    }\n\n    if (0 === indentation) {\n      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {\n        indentation = matches[0].length;\n      }\n    }\n\n    if (indentation > 0) {\n      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];\n\n      if (pattern == null) {\n        pattern = new Pattern('^ {' + indentation + '}(.*)$');\n        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;\n      }\n\n      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {\n        if (isCurrentLineBlank) {\n          text += this.currentLine.slice(indentation);\n        } else {\n          text += matches[1];\n        }\n\n        if (notEOF = this.moveToNextLine()) {\n          text += \"\\n\";\n          isCurrentLineBlank = this.isCurrentLineBlank();\n        }\n      }\n    } else if (notEOF) {\n      text += \"\\n\";\n    }\n\n    if (notEOF) {\n      this.moveToPreviousLine();\n    }\n\n    if ('>' === separator) {\n      newText = '';\n      ref = text.split(\"\\n\");\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        line = ref[j];\n\n        if (line.length === 0 || line.charAt(0) === ' ') {\n          newText = Utils.rtrim(newText, ' ') + line + \"\\n\";\n        } else {\n          newText += line + ' ';\n        }\n      }\n\n      text = newText;\n    }\n\n    if ('+' !== indicator) {\n      text = Utils.rtrim(text);\n    }\n\n    if ('' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, \"\\n\");\n    } else if ('-' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, '');\n    }\n\n    return text;\n  };\n\n  Parser.prototype.isNextLineIndented = function (ignoreComments) {\n    var EOF, currentIndentation, ret;\n\n    if (ignoreComments == null) {\n      ignoreComments = true;\n    }\n\n    currentIndentation = this.getCurrentLineIndentation();\n    EOF = !this.moveToNextLine();\n\n    if (ignoreComments) {\n      while (!EOF && this.isCurrentLineEmpty()) {\n        EOF = !this.moveToNextLine();\n      }\n    } else {\n      while (!EOF && this.isCurrentLineBlank()) {\n        EOF = !this.moveToNextLine();\n      }\n    }\n\n    if (EOF) {\n      return false;\n    }\n\n    ret = false;\n\n    if (this.getCurrentLineIndentation() > currentIndentation) {\n      ret = true;\n    }\n\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isCurrentLineEmpty = function () {\n    var trimmedLine;\n    trimmedLine = Utils.trim(this.currentLine, ' ');\n    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.isCurrentLineBlank = function () {\n    return '' === Utils.trim(this.currentLine, ' ');\n  };\n\n  Parser.prototype.isCurrentLineComment = function () {\n    var ltrimmedLine;\n    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');\n    return ltrimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.cleanup = function (value) {\n    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;\n\n    if (value.indexOf(\"\\r\") !== -1) {\n      value = value.split(\"\\r\\n\").join(\"\\n\").split(\"\\r\").join(\"\\n\");\n    }\n\n    count = 0;\n    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];\n    this.offset += count;\n    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];\n\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n    }\n\n    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];\n\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');\n    }\n\n    lines = value.split(\"\\n\");\n    smallestIndent = -1;\n\n    for (j = 0, len = lines.length; j < len; j++) {\n      line = lines[j];\n\n      if (Utils.trim(line, ' ').length === 0) {\n        continue;\n      }\n\n      indent = line.length - Utils.ltrim(line).length;\n\n      if (smallestIndent === -1 || indent < smallestIndent) {\n        smallestIndent = indent;\n      }\n    }\n\n    if (smallestIndent > 0) {\n      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {\n        line = lines[i];\n        lines[i] = line.slice(smallestIndent);\n      }\n\n      value = lines.join(\"\\n\");\n    }\n\n    return value;\n  };\n\n  Parser.prototype.isNextLineUnIndentedCollection = function (currentIndentation) {\n    var notEOF, ret;\n\n    if (currentIndentation == null) {\n      currentIndentation = null;\n    }\n\n    if (currentIndentation == null) {\n      currentIndentation = this.getCurrentLineIndentation();\n    }\n\n    notEOF = this.moveToNextLine();\n\n    while (notEOF && this.isCurrentLineEmpty()) {\n      notEOF = this.moveToNextLine();\n    }\n\n    if (false === notEOF) {\n      return false;\n    }\n\n    ret = false;\n\n    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {\n      ret = true;\n    }\n\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isStringUnIndentedCollectionItem = function () {\n    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';\n  };\n\n  return Parser;\n}();\n\nmodule.exports = Parser;","map":{"version":3,"names":["Inline","ParseException","ParseMore","Parser","Pattern","Utils","require","prototype","PATTERN_FOLDED_SCALAR_ALL","PATTERN_FOLDED_SCALAR_END","PATTERN_SEQUENCE_ITEM","PATTERN_ANCHOR_VALUE","PATTERN_COMPACT_NOTATION","REGEX_QUOTED_STRING","PATTERN_MAPPING_ITEM","PATTERN_DECIMAL","PATTERN_INDENT_SPACES","PATTERN_TRAILING_LINES","PATTERN_YAML_HEADER","PATTERN_LEADING_COMMENTS","PATTERN_DOCUMENT_MARKER_START","PATTERN_DOCUMENT_MARKER_END","PATTERN_FOLDED_SCALAR_BY_INDENTATION","CONTEXT_NONE","CONTEXT_SEQUENCE","CONTEXT_MAPPING","offset","lines","currentLineNb","currentLine","refs","parse","value","exceptionOnInvalidType","objectDecoder","alias","allowOverwrite","block","c","context","data","e","first","i","indent","isRef","j","k","key","l","lastKey","len","len1","len2","len3","lineCount","m","matches","mergeNode","n","name","parsed","parsedItem","parser","ref","ref1","ref2","refName","refValue","val","values","cleanup","split","moveToNextLine","isCurrentLineEmpty","getRealCurrentLineNb","exec","trim","ltrim","indexOf","length","isNextLineUnIndentedCollection","push","getNextEmbedBlock","leadspaces","getCurrentLineIndentation","isNextLineIndented","parseValue","configure","parseScalar","error","parsedLine","snippet","slice","Array","String","hasOwnProperty","isEmpty","charAt","indentation","includeUnindentedCollection","isItUnindentedCollection","newIndent","removeComments","removeCommentsPattern","unindentedEmbedBlock","isStringUnIndentedCollectionItem","test","isCurrentLineComment","isCurrentLineBlank","moveToPreviousLine","join","foldedIndent","modifiers","pos","substr","Math","abs","parseInt","isNaN","parseFoldedScalar","separator","replace","type","indicator","line","newText","notEOF","pattern","text","rtrim","ignoreComments","EOF","currentIndentation","ret","trimmedLine","ltrimmedLine","count","smallestIndent","trimmedValue","replaceAll","subStrCount","module","exports"],"sources":["/Users/Paul_1/Desktop/Th/Projekte/Informatikprojekt/InformatikprojektWvueCLI&Router/app/frontend/node_modules/yamljs/lib/Parser.js"],"sourcesContent":["// Generated by CoffeeScript 1.12.4\nvar Inline, ParseException, ParseMore, Parser, Pattern, Utils;\n\nInline = require('./Inline');\n\nPattern = require('./Pattern');\n\nUtils = require('./Utils');\n\nParseException = require('./Exception/ParseException');\n\nParseMore = require('./Exception/ParseMore');\n\nParser = (function() {\n  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\\\|>]*)\\\\s+)?(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n\n  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n\n  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\\\-((?<leadspaces>\\\\s+)(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');\n\n  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\{\\\\[].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\[\\\\{].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\\\d+');\n\n  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');\n\n  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\\n*)$');\n\n  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\\\%YAML[: ][\\\\d\\\\.]+.*\\n', 'm');\n\n  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\\\#.*?\\n)+', 'm');\n\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\\\-\\\\-\\\\-.*?\\n', 'm');\n\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\\\.\\\\.\\\\.\\\\s*$', 'm');\n\n  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};\n\n  Parser.prototype.CONTEXT_NONE = 0;\n\n  Parser.prototype.CONTEXT_SEQUENCE = 1;\n\n  Parser.prototype.CONTEXT_MAPPING = 2;\n\n  function Parser(offset) {\n    this.offset = offset != null ? offset : 0;\n    this.lines = [];\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.refs = {};\n  }\n\n  Parser.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {\n    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;\n    if (exceptionOnInvalidType == null) {\n      exceptionOnInvalidType = false;\n    }\n    if (objectDecoder == null) {\n      objectDecoder = null;\n    }\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.lines = this.cleanup(value).split(\"\\n\");\n    data = null;\n    context = this.CONTEXT_NONE;\n    allowOverwrite = false;\n    while (this.moveToNextLine()) {\n      if (this.isCurrentLineEmpty()) {\n        continue;\n      }\n      if (\"\\t\" === this.currentLine[0]) {\n        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      isRef = mergeNode = false;\n      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {\n        if (this.CONTEXT_MAPPING === context) {\n          throw new ParseException('You cannot define a sequence item when in a mapping');\n        }\n        context = this.CONTEXT_SEQUENCE;\n        if (data == null) {\n          data = [];\n        }\n        if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(null);\n          }\n        } else {\n          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {\n            c = this.getRealCurrentLineNb();\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            block = values.value;\n            indent = this.getCurrentLineIndentation();\n            if (this.isNextLineIndented(false)) {\n              block += \"\\n\" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);\n            }\n            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));\n          }\n        }\n      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {\n        if (this.CONTEXT_SEQUENCE === context) {\n          throw new ParseException('You cannot define a mapping item when in a sequence');\n        }\n        context = this.CONTEXT_MAPPING;\n        if (data == null) {\n          data = {};\n        }\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        try {\n          key = Inline.parseScalar(values.key);\n        } catch (error) {\n          e = error;\n          e.parsedLine = this.getRealCurrentLineNb() + 1;\n          e.snippet = this.currentLine;\n          throw e;\n        }\n        if ('<<' === key) {\n          mergeNode = true;\n          allowOverwrite = true;\n          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {\n            refName = values.value.slice(1);\n            if (this.refs[refName] == null) {\n              throw new ParseException('Reference \"' + refName + '\" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            refValue = this.refs[refName];\n            if (typeof refValue !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (refValue instanceof Array) {\n              for (i = j = 0, len = refValue.length; j < len; i = ++j) {\n                value = refValue[i];\n                if (data[name = String(i)] == null) {\n                  data[name] = value;\n                }\n              }\n            } else {\n              for (key in refValue) {\n                value = refValue[key];\n                if (data[key] == null) {\n                  data[key] = value;\n                }\n              }\n            }\n          } else {\n            if ((values.value != null) && values.value !== '') {\n              value = values.value;\n            } else {\n              value = this.getNextEmbedBlock();\n            }\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            parsed = parser.parse(value, exceptionOnInvalidType);\n            if (typeof parsed !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (parsed instanceof Array) {\n              for (l = 0, len1 = parsed.length; l < len1; l++) {\n                parsedItem = parsed[l];\n                if (typeof parsedItem !== 'object') {\n                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);\n                }\n                if (parsedItem instanceof Array) {\n                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {\n                    value = parsedItem[i];\n                    k = String(i);\n                    if (!data.hasOwnProperty(k)) {\n                      data[k] = value;\n                    }\n                  }\n                } else {\n                  for (key in parsedItem) {\n                    value = parsedItem[key];\n                    if (!data.hasOwnProperty(key)) {\n                      data[key] = value;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (key in parsed) {\n                value = parsed[key];\n                if (!data.hasOwnProperty(key)) {\n                  data[key] = value;\n                }\n              }\n            }\n          }\n        } else if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (mergeNode) {\n\n        } else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (!(this.isNextLineIndented()) && !(this.isNextLineUnIndentedCollection())) {\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = null;\n            }\n          } else {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = val;\n            }\n          }\n        } else {\n          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);\n          if (allowOverwrite || data[key] === void 0) {\n            data[key] = val;\n          }\n        }\n      } else {\n        lineCount = this.lines.length;\n        if (1 === lineCount || (2 === lineCount && Utils.isEmpty(this.lines[1]))) {\n          try {\n            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n          if (typeof value === 'object') {\n            if (value instanceof Array) {\n              first = value[0];\n            } else {\n              for (key in value) {\n                first = value[key];\n                break;\n              }\n            }\n            if (typeof first === 'string' && first.indexOf('*') === 0) {\n              data = [];\n              for (n = 0, len3 = value.length; n < len3; n++) {\n                alias = value[n];\n                data.push(this.refs[alias.slice(1)]);\n              }\n              value = data;\n            }\n          }\n          return value;\n        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {\n          try {\n            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      if (isRef) {\n        if (data instanceof Array) {\n          this.refs[isRef] = data[data.length - 1];\n        } else {\n          lastKey = null;\n          for (key in data) {\n            lastKey = key;\n          }\n          this.refs[isRef] = data[lastKey];\n        }\n      }\n    }\n    if (Utils.isEmpty(data)) {\n      return null;\n    } else {\n      return data;\n    }\n  };\n\n  Parser.prototype.getRealCurrentLineNb = function() {\n    return this.currentLineNb + this.offset;\n  };\n\n  Parser.prototype.getCurrentLineIndentation = function() {\n    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;\n  };\n\n  Parser.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {\n    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;\n    if (indentation == null) {\n      indentation = null;\n    }\n    if (includeUnindentedCollection == null) {\n      includeUnindentedCollection = false;\n    }\n    this.moveToNextLine();\n    if (indentation == null) {\n      newIndent = this.getCurrentLineIndentation();\n      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);\n      if (!(this.isCurrentLineEmpty()) && 0 === newIndent && !unindentedEmbedBlock) {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    } else {\n      newIndent = indentation;\n    }\n    data = [this.currentLine.slice(newIndent)];\n    if (!includeUnindentedCollection) {\n      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);\n    }\n    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;\n    removeComments = !removeCommentsPattern.test(this.currentLine);\n    while (this.moveToNextLine()) {\n      indent = this.getCurrentLineIndentation();\n      if (indent === newIndent) {\n        removeComments = !removeCommentsPattern.test(this.currentLine);\n      }\n      if (removeComments && this.isCurrentLineComment()) {\n        continue;\n      }\n      if (this.isCurrentLineBlank()) {\n        data.push(this.currentLine.slice(newIndent));\n        continue;\n      }\n      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {\n        this.moveToPreviousLine();\n        break;\n      }\n      if (indent >= newIndent) {\n        data.push(this.currentLine.slice(newIndent));\n      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {\n\n      } else if (0 === indent) {\n        this.moveToPreviousLine();\n        break;\n      } else {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    }\n    return data.join(\"\\n\");\n  };\n\n  Parser.prototype.moveToNextLine = function() {\n    if (this.currentLineNb >= this.lines.length - 1) {\n      return false;\n    }\n    this.currentLine = this.lines[++this.currentLineNb];\n    return true;\n  };\n\n  Parser.prototype.moveToPreviousLine = function() {\n    this.currentLine = this.lines[--this.currentLineNb];\n  };\n\n  Parser.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {\n    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;\n    if (0 === value.indexOf('*')) {\n      pos = value.indexOf('#');\n      if (pos !== -1) {\n        value = value.substr(1, pos - 2);\n      } else {\n        value = value.slice(1);\n      }\n      if (this.refs[value] === void 0) {\n        throw new ParseException('Reference \"' + value + '\" does not exist.', this.currentLine);\n      }\n      return this.refs[value];\n    }\n    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {\n      modifiers = (ref = matches.modifiers) != null ? ref : '';\n      foldedIndent = Math.abs(parseInt(modifiers));\n      if (isNaN(foldedIndent)) {\n        foldedIndent = 0;\n      }\n      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);\n      if (matches.type != null) {\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        return Inline.parseScalar(matches.type + ' ' + val);\n      } else {\n        return val;\n      }\n    }\n    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '\"' || ref1 === \"'\") {\n      while (true) {\n        try {\n          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n        } catch (error) {\n          e = error;\n          if (e instanceof ParseMore && this.moveToNextLine()) {\n            value += \"\\n\" + Utils.trim(this.currentLine, ' ');\n          } else {\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n      }\n    } else {\n      if (this.isNextLineIndented()) {\n        value += \"\\n\" + this.getNextEmbedBlock();\n      }\n      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n    }\n  };\n\n  Parser.prototype.parseFoldedScalar = function(separator, indicator, indentation) {\n    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;\n    if (indicator == null) {\n      indicator = '';\n    }\n    if (indentation == null) {\n      indentation = 0;\n    }\n    notEOF = this.moveToNextLine();\n    if (!notEOF) {\n      return '';\n    }\n    isCurrentLineBlank = this.isCurrentLineBlank();\n    text = '';\n    while (notEOF && isCurrentLineBlank) {\n      if (notEOF = this.moveToNextLine()) {\n        text += \"\\n\";\n        isCurrentLineBlank = this.isCurrentLineBlank();\n      }\n    }\n    if (0 === indentation) {\n      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {\n        indentation = matches[0].length;\n      }\n    }\n    if (indentation > 0) {\n      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];\n      if (pattern == null) {\n        pattern = new Pattern('^ {' + indentation + '}(.*)$');\n        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;\n      }\n      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {\n        if (isCurrentLineBlank) {\n          text += this.currentLine.slice(indentation);\n        } else {\n          text += matches[1];\n        }\n        if (notEOF = this.moveToNextLine()) {\n          text += \"\\n\";\n          isCurrentLineBlank = this.isCurrentLineBlank();\n        }\n      }\n    } else if (notEOF) {\n      text += \"\\n\";\n    }\n    if (notEOF) {\n      this.moveToPreviousLine();\n    }\n    if ('>' === separator) {\n      newText = '';\n      ref = text.split(\"\\n\");\n      for (j = 0, len = ref.length; j < len; j++) {\n        line = ref[j];\n        if (line.length === 0 || line.charAt(0) === ' ') {\n          newText = Utils.rtrim(newText, ' ') + line + \"\\n\";\n        } else {\n          newText += line + ' ';\n        }\n      }\n      text = newText;\n    }\n    if ('+' !== indicator) {\n      text = Utils.rtrim(text);\n    }\n    if ('' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, \"\\n\");\n    } else if ('-' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, '');\n    }\n    return text;\n  };\n\n  Parser.prototype.isNextLineIndented = function(ignoreComments) {\n    var EOF, currentIndentation, ret;\n    if (ignoreComments == null) {\n      ignoreComments = true;\n    }\n    currentIndentation = this.getCurrentLineIndentation();\n    EOF = !this.moveToNextLine();\n    if (ignoreComments) {\n      while (!EOF && this.isCurrentLineEmpty()) {\n        EOF = !this.moveToNextLine();\n      }\n    } else {\n      while (!EOF && this.isCurrentLineBlank()) {\n        EOF = !this.moveToNextLine();\n      }\n    }\n    if (EOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() > currentIndentation) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isCurrentLineEmpty = function() {\n    var trimmedLine;\n    trimmedLine = Utils.trim(this.currentLine, ' ');\n    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.isCurrentLineBlank = function() {\n    return '' === Utils.trim(this.currentLine, ' ');\n  };\n\n  Parser.prototype.isCurrentLineComment = function() {\n    var ltrimmedLine;\n    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');\n    return ltrimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.cleanup = function(value) {\n    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;\n    if (value.indexOf(\"\\r\") !== -1) {\n      value = value.split(\"\\r\\n\").join(\"\\n\").split(\"\\r\").join(\"\\n\");\n    }\n    count = 0;\n    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];\n    this.offset += count;\n    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n    }\n    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');\n    }\n    lines = value.split(\"\\n\");\n    smallestIndent = -1;\n    for (j = 0, len = lines.length; j < len; j++) {\n      line = lines[j];\n      if (Utils.trim(line, ' ').length === 0) {\n        continue;\n      }\n      indent = line.length - Utils.ltrim(line).length;\n      if (smallestIndent === -1 || indent < smallestIndent) {\n        smallestIndent = indent;\n      }\n    }\n    if (smallestIndent > 0) {\n      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {\n        line = lines[i];\n        lines[i] = line.slice(smallestIndent);\n      }\n      value = lines.join(\"\\n\");\n    }\n    return value;\n  };\n\n  Parser.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {\n    var notEOF, ret;\n    if (currentIndentation == null) {\n      currentIndentation = null;\n    }\n    if (currentIndentation == null) {\n      currentIndentation = this.getCurrentLineIndentation();\n    }\n    notEOF = this.moveToNextLine();\n    while (notEOF && this.isCurrentLineEmpty()) {\n      notEOF = this.moveToNextLine();\n    }\n    if (false === notEOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isStringUnIndentedCollectionItem = function() {\n    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';\n  };\n\n  return Parser;\n\n})();\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}