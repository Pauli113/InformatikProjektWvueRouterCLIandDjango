{"ast":null,"code":"var fs = require('fs'),\n    path = require('path');\n\nexports.promiseFiles = function promiseFiles(dir, type, options) {\n  type = type || 'file';\n\n  var processor = function (res, rej) {\n    var cb = function (err, data) {\n      if (err) return rej(err);\n      res(data);\n    };\n\n    exports.files(dir, type, cb, options);\n  };\n\n  return new Promise(processor);\n};\n/**\n * find all files or subdirs (recursive) and pass to callback fn\n *\n * @param {string} dir directory in which to recurse files or subdirs\n * @param {string} type type of dir entry to recurse ('file', 'dir', or 'all', defaults to 'file')\n * @param {function(error, <Array.<string>)} callback fn to call when done\n * @example\n * dir.files(__dirname, function(err, files) {\n *      if (err) throw err;\n *      console.log('files:', files);\n *  });\n */\n\n\nexports.files = function files(dir, type, callback, options) {\n  var ofType = typeof type;\n\n  if (ofType == 'object') {\n    options = options || type;\n    type = 'file';\n\n    callback = function () {};\n  } else if (ofType !== 'string') {\n    //ignoreType = callback;\n    callback = type;\n    type = 'file';\n  }\n\n  options = options || {};\n  var pending,\n      results = {\n    files: [],\n    dirs: []\n  };\n\n  var done = function () {\n    if (type === 'combine') {\n      results = results.files.concat(results.dirs);\n    } else if (!type || options.ignoreType || ['all', 'combine'].indexOf(type) >= 0) {\n      results = results;\n    } else {\n      results = results[type + 's'];\n    }\n\n    if (options.sync) return;\n    callback(null, results);\n  };\n\n  var getStatHandler = function (statPath, name, lstatCalled) {\n    return function (err, stat) {\n      if (err) {\n        if (!lstatCalled) {\n          return fs.lstat(statPath, getStatHandler(statPath, name, true));\n        }\n\n        return callback(err);\n      }\n\n      var pushVal = options.shortName ? name : statPath;\n\n      if (stat && stat.isDirectory() && stat.mode !== 17115) {\n        if (type !== 'file') {\n          results.dirs.push(pushVal);\n        }\n\n        if (options.recursive == null || options.recursive) {\n          var subloop = function (err, res) {\n            if (err) {\n              return callback(err);\n            }\n\n            if (type === 'combine') {\n              results.files = results.files.concat(res);\n            } else if (type === 'all') {\n              results.files = results.files.concat(res.files);\n              results.dirs = results.dirs.concat(res.dirs);\n            } else if (type === 'file') {\n              results.files = results.files.concat(res.files);\n            } else {\n              results.dirs = results.dirs.concat(res.dirs);\n            }\n\n            if (! --pending) {\n              done();\n            }\n          };\n\n          var newOptions = Object.assign({}, options);\n          newOptions.ignoreType = true;\n          var moreResults = files(statPath, type, subloop, newOptions);\n\n          if (options.sync) {\n            subloop(null, moreResults);\n          }\n        } else if (! --pending) {\n          done();\n        }\n      } else {\n        if (type !== 'dir') {\n          results.files.push(pushVal);\n        } // should be the last statement in statHandler\n\n\n        if (! --pending) {\n          done();\n        }\n      }\n    };\n  };\n\n  var bufdir = Buffer.from(dir);\n\n  const onDirRead = function (err, list) {\n    if (err) return callback(err);\n    pending = list.length;\n    if (!pending) return done();\n\n    for (var file, i = 0, l = list.length; i < l; i++) {\n      var fname = list[i].toString();\n      file = path.join(dir, fname);\n      var buffile = Buffer.concat([bufdir, Buffer.from(path.sep), list[i]]);\n\n      if (options.sync) {\n        var res = fs.statSync(buffile);\n        getStatHandler(file, fname)(null, res);\n      } else {\n        fs.stat(buffile, getStatHandler(file, fname));\n      }\n    }\n\n    return results;\n  };\n\n  const onStat = function (err, stat) {\n    if (err) return callback(err);\n    if (stat && stat.mode === 17115) return done();\n\n    if (options.sync) {\n      const list = fs.readdirSync(bufdir, {\n        encoding: 'buffer'\n      });\n      return onDirRead(null, list);\n    } else {\n      fs.readdir(bufdir, {\n        encoding: 'buffer'\n      }, onDirRead);\n    }\n  };\n\n  if (options.sync) {\n    const stat = fs.statSync(bufdir);\n    return onStat(null, stat);\n  } else {\n    fs.stat(bufdir, onStat);\n  }\n};\n/**\n * find all files and subdirs in  a directory (recursive) and pass them to callback fn\n *\n * @param {string} dir directory in which to recurse files or subdirs\n * @param {boolean} combine whether to combine both subdirs and filepaths into one array (default false)\n * @param {function(error, Object.<<Array.<string>, Array.<string>>)} callback fn to call when done\n * @example\n * dir.paths(__dirname, function (err, paths) {\n *     if (err) throw err;\n *     console.log('files:', paths.files);\n *     console.log('subdirs:', paths.dirs);\n * });\n * dir.paths(__dirname, true, function (err, paths) {\n *      if (err) throw err;\n *      console.log('paths:', paths);\n * });\n */\n\n\nexports.paths = function paths(dir, combine, callback) {\n  var type;\n\n  if (typeof combine === 'function') {\n    callback = combine;\n    combine = false;\n  }\n\n  exports.files(dir, 'all', function (err, results) {\n    if (err) return callback(err);\n\n    if (combine) {\n      callback(null, results.files.concat(results.dirs));\n    } else {\n      callback(null, results);\n    }\n  });\n};\n/**\n * find all subdirs (recursive) of a directory and pass them to callback fn\n *\n * @param {string} dir directory in which to find subdirs\n * @param {string} type type of dir entry to recurse ('file' or 'dir', defaults to 'file')\n * @param {function(error, <Array.<string>)} callback fn to call when done\n * @example\n * dir.subdirs(__dirname, function (err, paths) {\n *      if (err) throw err;\n *      console.log('files:', paths.files);\n *      console.log('subdirs:', paths.dirs);\n * });\n */\n\n\nexports.subdirs = function subdirs(dir, callback, type, options) {\n  options = options || {};\n\n  const iCallback = function (err, subdirs) {\n    if (err) return callback(err);\n\n    if (type == 'combine') {\n      subdirs = subdirs.files.concat(subdirs.dirs);\n    }\n\n    if (options.sync) return subdirs;\n    callback(null, subdirs);\n  };\n\n  const res = exports.files(dir, 'dir', iCallback, options);\n\n  if (options && options.sync) {\n    return iCallback(null, res);\n  }\n};","map":{"version":3,"names":["fs","require","path","exports","promiseFiles","dir","type","options","processor","res","rej","cb","err","data","files","Promise","callback","ofType","pending","results","dirs","done","concat","ignoreType","indexOf","sync","getStatHandler","statPath","name","lstatCalled","stat","lstat","pushVal","shortName","isDirectory","mode","push","recursive","subloop","newOptions","Object","assign","moreResults","bufdir","Buffer","from","onDirRead","list","length","file","i","l","fname","toString","join","buffile","sep","statSync","onStat","readdirSync","encoding","readdir","paths","combine","subdirs","iCallback"],"sources":["/Users/Paul_1/node_modules/node-dir/lib/paths.js"],"sourcesContent":["var fs = require('fs'),\n    path = require('path');\n\nexports.promiseFiles = function promiseFiles(dir, type, options){\n  type = type || 'file'\n\n  var processor = function(res,rej){\n    var cb = function(err,data){\n      if(err)return rej(err)\n      res(data)\n    }\n    exports.files(dir,type,cb,options)\n  }\n  return new Promise(processor)\n}\n\n/**\n * find all files or subdirs (recursive) and pass to callback fn\n *\n * @param {string} dir directory in which to recurse files or subdirs\n * @param {string} type type of dir entry to recurse ('file', 'dir', or 'all', defaults to 'file')\n * @param {function(error, <Array.<string>)} callback fn to call when done\n * @example\n * dir.files(__dirname, function(err, files) {\n *      if (err) throw err;\n *      console.log('files:', files);\n *  });\n */\nexports.files = function files(dir, type, callback, options) {\n  var ofType = typeof type\n  if(ofType == 'object'){\n    options = options || type\n    type = 'file'\n    callback = function(){}\n  }else if (ofType !== 'string') {\n    //ignoreType = callback;\n    callback = type;\n    type = 'file';\n  }\n  \n  options = options || {}\n\n  var pending,\n      results = {\n          files: [],\n          dirs: []\n      };\n\n  var done = function() {\n    if(type==='combine'){\n      results = results.files.concat(results.dirs)\n    } else if (!type || options.ignoreType || ['all','combine'].indexOf(type)>=0) {\n        results = results\n    } else {\n      results = results[type + 's']\n    }\n\n    if(options.sync)return;\n\n\n    callback(null, results);\n  };\n\n  var getStatHandler = function(statPath, name, lstatCalled) {\n    return function(err, stat) {\n      if (err) {\n        if (!lstatCalled) {\n          return fs.lstat(statPath, getStatHandler(statPath, name, true));\n        }\n        return callback(err);\n      }\n\n      var pushVal = options.shortName ? name : statPath\n\n      if (stat && stat.isDirectory() && stat.mode !== 17115) {\n        if (type !== 'file') {\n          results.dirs.push(pushVal);\n        }\n\n        if (options.recursive==null || options.recursive) {\n          var subloop = function(err, res) {\n            if (err){\n                return callback(err)\n            }\n            \n            if(type === 'combine'){\n              results.files = results.files.concat(res);\n            }else if (type === 'all') {\n              results.files = results.files.concat(res.files);\n              results.dirs = results.dirs.concat(res.dirs);\n            } else if (type === 'file') {\n                results.files = results.files.concat(res.files);\n            } else {\n                results.dirs = results.dirs.concat(res.dirs);\n            }\n\n            if (!--pending){\n              done();\n            }\n          }\n\n          var newOptions = Object.assign({}, options)\n          newOptions.ignoreType = true\n          var moreResults = files(statPath, type, subloop, newOptions);\n\n          if(options.sync){\n            subloop(null, moreResults)\n          }\n        }else if (!--pending){\n          done()\n        }\n      } else {\n        if (type !== 'dir') {\n          results.files.push(pushVal);\n        }\n        // should be the last statement in statHandler\n        if (!--pending){\n          done()\n        }\n      }\n    }\n  }\n\n  var bufdir = Buffer.from(dir);\n\n  const onDirRead = function(err, list) {\n    if (err) return callback(err);\n    \n    pending = list.length;\n    if (!pending) return done();\n    \n    for (var file, i = 0, l = list.length; i < l; i++) {\n      var fname = list[i].toString();\n      file = path.join(dir, fname);\n      var buffile = Buffer.concat([bufdir, Buffer.from(path.sep), list[i]]);\n\n      if(options.sync){\n        var res = fs.statSync(buffile);\n        getStatHandler(file,fname)(null, res)\n      }else{\n        fs.stat(buffile, getStatHandler(file,fname));\n      }\n    }\n\n    return results\n  }\n\n  const onStat = function(err, stat) {\n    if (err) return callback(err);\n    if (stat && stat.mode === 17115) return done();\n\n    if(options.sync){\n      const list = fs.readdirSync(bufdir, {encoding: 'buffer'})\n      return onDirRead(null, list)\n    }else{\n      fs.readdir(bufdir, {encoding: 'buffer'}, onDirRead)\n    }\n  }\n\n  if(options.sync){\n    const stat = fs.statSync(bufdir);\n    return onStat(null, stat)\n  }else{\n    fs.stat(bufdir, onStat);\n  }\n};\n\n\n/**\n * find all files and subdirs in  a directory (recursive) and pass them to callback fn\n *\n * @param {string} dir directory in which to recurse files or subdirs\n * @param {boolean} combine whether to combine both subdirs and filepaths into one array (default false)\n * @param {function(error, Object.<<Array.<string>, Array.<string>>)} callback fn to call when done\n * @example\n * dir.paths(__dirname, function (err, paths) {\n *     if (err) throw err;\n *     console.log('files:', paths.files);\n *     console.log('subdirs:', paths.dirs);\n * });\n * dir.paths(__dirname, true, function (err, paths) {\n *      if (err) throw err;\n *      console.log('paths:', paths);\n * });\n */\nexports.paths = function paths(dir, combine, callback) {\n\n    var type;\n\n    if (typeof combine === 'function') {\n        callback = combine;\n        combine = false;\n    }\n\n    exports.files(dir, 'all', function(err, results) {\n        if (err) return callback(err);\n        if (combine) {\n\n            callback(null, results.files.concat(results.dirs));\n        } else {\n            callback(null, results);\n        }\n    });\n};\n\n\n/**\n * find all subdirs (recursive) of a directory and pass them to callback fn\n *\n * @param {string} dir directory in which to find subdirs\n * @param {string} type type of dir entry to recurse ('file' or 'dir', defaults to 'file')\n * @param {function(error, <Array.<string>)} callback fn to call when done\n * @example\n * dir.subdirs(__dirname, function (err, paths) {\n *      if (err) throw err;\n *      console.log('files:', paths.files);\n *      console.log('subdirs:', paths.dirs);\n * });\n */\nexports.subdirs = function subdirs(dir, callback, type, options) {\n  options = options || {}\n\n  const iCallback = function(err, subdirs) {\n    if (err) return callback(err);\n\n    if(type=='combine'){\n      subdirs = subdirs.files.concat(subdirs.dirs)\n    }\n    \n    if(options.sync)return subdirs\n\n    callback(null, subdirs);\n  }\n\n  const res = exports.files(dir, 'dir', iCallback, options)\n\n  if(options && options.sync){\n    return iCallback(null,res)\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}